# CSSTidy - CSS Parser and Optimiser
#
# CSS Optimising Class
# This class optimises CSS data generated by csstidy.
#
# This file is part of CSSTidy.
#
# CSSTidy is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# CSSTidy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CSSTidy; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# @license http://opensource.org/licenses/gpl-license.php GNU Public License
# @package csstidy
# @author Florian Schmitz (floele at gmail dot com) 2005-2006

# CSS Optimising Class
#
# This class optimises CSS data generated by csstidy.
#
# @package csstidy
# @author Dj Gilcrease (digitalxero at gmail dot com) 2005-2006
# @version 1.0

from tidydata import *

class CSSTidyOptimise(object):
    # Constructor
    # @param array $css contains the class csstidy
    # @access private
    # @version 1.0
    def __init__(self, css):
        self.parser    = css
        self.css       = css.css
        self.sub_value = css._sub_value
        self.at        = css._at
        self.selector  = css._selector
        self.property  = css._property
        self._value     = css._value

    # Optimises $css after parsing
    # @access public
    # @version 1.0
    def postparse(self):
        if self.parser.get_cfg('preserve_css'):
            return

        if self.parser.get_cfg('merge_selectors') == 2:
            for medium, value in self.css.iteritems():
                self.merge_selectors(self.css[medium])

        if self.parser.get_cfg('optimise_shorthands') > 0:
            for medium, value in self.css.iteritems():
                for selector, value1 in value:
                    self.css[medium][selector] = self.merge_4value_shorthands(self.css[medium][selector])

                    if self.parser.get_cfg('optimise_shorthands') < 2:
                        continue

                    self.css[medium][selector] = self.merge_bg(self.css[medium][selector])
                    if len(self.css[medium][selector]) == 0:
                        del self.css[medium][selector]

    # Optimises values
    # @access public
    # @version 1.0
    def value(self):
        shorthands = GLOBALS['csstidy']['shorthands']

        #optimise shorthand properties
        if shorthands.has_key(self.property):
            temp = self.shorthand(self._value); # FIXME - move
            if temp != self._value:
                self.parser.log('Optimised shorthand notation (' + self.property + '): Changed "' + self._value + '" to "' + temp + '"', 'Information')

            self._value = temp

        #Remove whitespace at ! important
        if self._value != self.compress_important(self._value):
            self.parser.log('Optimised !important', 'Information')

    # Optimises shorthands
    # @access public
    # @version 1.0
    def shorthands(self):
        shorthands = GLOBALS['csstidy']['shorthands']

        if not self.parser.get_cfg('optimise_shorthands') or self.parser.get_cfg('preserve_css'):
            return

        if self.property == 'background' and self.parser.get_cfg('optimise_shorthands') > 1:
            del self.css[self.at][self.selector]['background']
            self.parser.merge_css_blocks(self.at, self.selector, self.dissolve_short_bg(self._value))

        if shorthands.has_key(self.property):
            self.parser.merge_css_blocks(self.at, self.selector, self.dissolve_4value_shorthands(self.property, self._value))
            if isinstance(shorthands[self.property], list):
                del self.css[self.at][self.selector][self.property]

    # Optimises a sub-value
    # @access public
    # @version 1.0
    def subvalue(self):
        replace_colors = GLOBALS['csstidy']['replace_colors']

        self.sub_value = self.sub_value.strip()
        if self.sub_value == '': # caution : '0'
            return

        important = ''
        if self.parser.is_important(self.sub_value):
            important = '!important'

        self.sub_value = self.parser.gvw_important(self.sub_value)

        #Compress font-weight
        if self.property == 'font-weight' and self.parser.get_cfg('compress_font-weight'):
            if self.sub_value == 'bold':
                self.sub_value = '700'
                self.parser.log('Optimised font-weight: Changed "bold" to "700"', 'Information')

            elif self.sub_value == 'normal':
                self.sub_value = '400'
                self.parser.log('Optimised font-weight: Changed "normal" to "400"', 'Information')

        temp = self.compress_numbers(self.sub_value)
        if temp != self.sub_value:
            if len(temp) > len(self.sub_value):
                self.parser.log('Fixed invalid number: Changed "' + self.sub_value + '" to "' + temp + '"', 'Warning')
            else:
                self.parser.log('Optimised number: Changed "' + self.sub_value + '" to "' + temp + '"', 'Information')

            self.sub_value = temp

        if self.parser.get_cfg('compress_colors'):
            temp = self.cut_color(self.sub_value)
            if temp != self.sub_value:
                if replace_colors.has_key(self.sub_value):
                    self.parser.log('Fixed invalid color name: Changed "' + self.sub_value + '" to "' + temp + '"', 'Warning')
                else:
                    self.parser.log('Optimised color: Changed "' + self.sub_value + '" to "' + temp + '"', 'Information')

            self.sub_value = temp

        self.sub_value += important

    # Compresses shorthand values. Example: margin:1px 1px 1px 1px . margin:1px
    # @param string $value
    # @access public
    # @return string
    # @version 1.0
    def shorthand(self, value):
        important = '';
        if self.parser.is_important(value):
            values = self.parser.gvw_important(value)
            important = '!important'
        else:
            values = value

        values = values.split(' ')
        if len(values) == 4:
            if values[0] == values[1] and values[0] == values[2] and values[0] == values[3]:
                return values[0] + important

            elif values[1] == values[3] and values[0] == values[2]:
                return values[0] + ' ' + values[1] + important

            elif values[1] == values[3]:
                return values[0] + ' ' + values[1] + ' ' + values[2] + important

        elif len(values) == 3:
            if values[0] == values[1] and values[0] == values[2]:
                return values[0] + important

            elif values[0] == values[2]:
                return values[0] + ' ' + values[1] + important

        elif len(values) == 2:
            if values[0] == values[1]:
                return values[0] + important

        return value

    # Removes unnecessary whitespace in ! important
    # @param string $string
    # @return string
    # @access public
    # @version 1.1
    def compress_important(self, string):
        if self.parser.is_important(string):
            string = self.parser.gvw_important(string) + '!important'

        return string

    # Color compression function. Converts all rgb() values to #-values and uses the short-form if possible. Also replaces 4 color names by #-values.
    # @param string $color
    # @return string
    # @version 1.1
    def cut_color(self, color):
        replace_colors = GLOBALS['csstidy']['replace_colors']

        #rgb(0,0,0) . #000000 (or #000 in this case later)
        if color[:4].lower() == 'rgb(':
            color_tmp = color[4:(len(color)-5)]
            color_tmp = color_tmp.split(',')

            for c in color_tmp:
                c = c.strip()
                if c[:-1] == '%':
                    c = round((255*color_tmp[i])/100)

                if color_tmp[i] > 255:
                    color_tmp[i] = 255

            color = '#'

            for i in xrange(3):
                if color_tmp[i] < 16:
                    color += '0' + str(hex(color_tmp[i])).replace('0x', '')
                else:
                    color += str(hex(color_tmp[i])).replace('0x', '')

        #Fix bad color names
        if replace_colors.has_key(color.lower()):
            color = replace_colors[color.lower()]

        #aabbcc . #abc
        if len(color) == 7:
            color_temp = color.lower()
            if color_temp[0] == '#' and color_temp[1] == color_temp[2] and color_temp[3] == color_temp[4] and color_temp[5] == color_temp[6]:
                color = '#' + color[1] + color[3] + color[5]

        opt_names = {}
        opt_names['black'] = '#000'
        opt_names['fuchsia'] = '#F0F'
        opt_names['white'] = '#FFF'
        opt_names['yellow'] = '#FF0'

        opt_names['#800000'] = 'maroon'
        opt_names['#ffa500'] = 'orange'
        opt_names['#808000'] = 'olive'
        opt_names['#800080'] = 'purple'
        opt_names['#008000'] = 'green'
        opt_names['#000080'] = 'navy'
        opt_names['#008080'] = 'teal'
        opt_names['#c0c0c0'] = 'silver'
        opt_names['#808080'] = 'gray'
        opt_names['#f00'] = 'red'

        if opt_names.has_key(color.lower()):
            return opt_names[color.lower()]

        return color

    # Compresses numbers (ie. 1.0 becomes 1 or 1.100 becomes 1.1 )
    # @param string $subvalue
    # @return string
    # @version 1.2
    def compress_numbers(self, subvalue):
        units = GLOBALS['csstidy']['units']
        unit_values = GLOBALS['csstidy']['unit_values']
        color_values = GLOBALS['csstidy']['color_values']

        #for font:1em/1em sans-serif...;
        if self.property == 'font':
            temp = subvalue.split('/')

        else:
            temp = [subvalue]

        for l in xrange(len(temp)):
            #continue if no numeric value
            if not (len(temp[l]) > 0 and (temp[l][0].isnumeric() or temp[l][0] == '+' or temp[l][0] == '-' )):
                continue

            #Fix bad colors
            if self.property in color_values:
                temp[l] = '#' + temp[l]

            if float(temp[l]) == 0:
                temp[l] = '0'

            else:
                unit_found = False
                for m in xrange(len(units)):
                    if temp[l].lower().find(units[m]) != -1:
                        temp[l] = float(temp[l]) + units[m]
                        unit_found = True
                        break;

                if not unit_found and self.property in unit_values:
                    temp[l] = float(temp[l]) + 'px'

                elif not unit_found:
                    temp[l] = float(temp[l])

                #Remove leading zero
                if abs(float(temp[l])) < 1:
                    if float(temp[l]) < 0:
                        temp[l] = '-' . temp[l][2:]
                    else:
                        temp[l] = temp[l][1:]
        if len(temp) > 1:
            return temp[0] + '/' + temp[1]

        return temp[0]

    # Merges selectors with same properties. Example: a{color:red} b{color:red} . a,b{color:red}
    # Very basic and has at least one bug. Hopefully there is a replacement soon.
    # @param array $array
    # @return array
    # @access public
    # @version 1.2
    def merge_selectors(self, array):
        css = array
        for key, value in css.iteritems():
            if css.has_key(key):
                continue

            newsel = ''

            #Check if properties also exist in another selector
            keys = []
            for selector, vali in css.iteritems():
                if selector == key:
                    continue

                if css[key] == vali:
                    keys.append(selector)

            if len(keys) > 0:
                newsel = key;
                del css[key]
                for selector in keys.itervalues():
                    del css[selector]
                    newsel += ',' + selector

                css[newsel] = value

        array = css

    # Dissolves properties like padding:10px 10px 10px to padding-top:10px;padding-bottom:10px;...
    # @param string $property
    # @param string $value
    # @return array
    # @version 1.0
    # @see merge_4value_shorthands()
    def dissolve_4value_shorthands(self, property, value):
        shorthands = GLOBALS['csstidy']['shorthands']
        ret = {}
        if isinstance(shorthands[property], list):
            ret[property] = value
            return ret

        important = ''
        if self.parser.is_important(value):
            value = self.parser.gvw_important(value)
            important = '!important'

        values = value.split(' ')


        ret = {}
        if len(values) == 4:
            for i in xrange(len(values)):
                ret[shorthands[property][i]] = values[i] + important

        elif len(values) == 3:
            ret[shorthands[property][0]] = values[0] + important
            ret[shorthands[property][1]] = values[1] + important
            ret[shorthands[property][3]] = values[1] + important
            ret[shorthands[property][2]] = values[2] + important

        elif len(values) == 2:
            ret[shorthands[property][0]] = values[0] + important
            ret[shorthands[property][2]] = values[0] + important
            ret[shorthands[property][1]] = values[1] + important
            ret[shorthands[property][3]] = values[1] + important

        else:
            ret[shorthands[property][0]] = values[0] + important
            ret[shorthands[property][2]] = values[0] + important
            ret[shorthands[property][1]] = values[0] + important
            ret[shorthands[property][3]] = values[0] + important

        return ret

    # Explodes a string as explode() does, however, not if $sep is escaped or within a string.
    # @param string $sep seperator
    # @param string $string
    # @return array
    # @version 1.0
    def explode_ws(self, sep, string):
        status = 'st'
        to = ''

        output = {}
        num = 0

        for i in xrange(len(string)):
            if status =='st':
                if string[i] == sep and not self.parser.escaped(string, i):
                    num += 1

                elif string[i] == '"' or string[i] == '\'' or string[i] == '(' and not self.parser.escaped(string, i):
                    status = 'str'
                    to = string[i]
                    if string[i] == '(':
                        to = ')'

                    if len(output) > num:
                        output[num] += string[i]
                    else:
                        output[num] = string[i]

                else:
                    if len(output) > num:
                        output[num] += string[i]
                    else:
                        output[num] = string[i]

            elif status == 'str':
                if string[i] == to and not self.parser.escaped(string, i):
                    status = 'st'

                    if len(output) > num:
                        output[num] += string[i]
                    else:
                        output[num] = string[i]

        try:
            output[0]
            return output
        except:
            return [output]

    # Merges Shorthand properties again, the opposite of dissolve_4value_shorthands()
    # @param array $array
    # @return array
    # @version 1.2
    # @see dissolve_4value_shorthands()
    def merge_4value_shorthands(self, array):
        ret = array
        shorthands = GLOBALS['csstidy']['shorthands']

        for key, value in shorthands.iteritems():
            if array.has_key(value[0]) and array.has_key(value[1]) and array.has_key(value[2]) and array.has_key(value[3]) and value != 0:
                ret[key] = ''

                important = ''
                for i in xrange(4):
                    val = array[value[i]]
                    if self.parser.is_important(val):
                        important = '!important'
                        ret[key] += self.parser.gvw_important(val) + ' '

                    else:
                        ret[key] += val + ' '

                    del ret[value[i]]

            ret[key] = self.shorthand(ret[key] + important.strip())

        return ret

    # Dissolve background property
    # @param string $str_value
    # @return array
    # @version 1.0
    # @see merge_bg()
    # @todo full CSS 3 compliance
    def dissolve_short_bg(self, str_value):
        background_prop_default = GLOBALS['csstidy']['background_prop_default']
        repeat = frozenset(['repeat','repeat-x','repeat-y','no-repeat','space'])
        attachment = frozenset(['scroll','fixed','local'])
        clip = frozenset(['border','padding'])
        origin = frozenset(['border','padding','content'])
        pos = frozenset(['top','center','bottom','left','right'])
        important = ''
        ret = {'background-image':None, 'background-size':None, 'background-repeat':None, 'background-position':None, 'background-attachment':None, 'background-clip':None, 'background-origin':None, 'background-color':None}

        if self.parser.is_important(str_value):
            important = ' !important'
            str_value = self.parser.gvw_important(str_value)

        str_value = self.explode_ws(',', str_value)

        have = {}
        for i in xrange(len(str_value)):
            have['clip'] = False
            have['pos'] = False
            have['color'] = False
            have['bg'] = False

            str_value[i] = self.explode_ws(' ', str_value[i].strip())

            for j in xrange(len(str_value[i])):
                if  not have['bg'] and (str_value[i][j][:4] == 'url(' or str_value[i][j] == 'none'):
                    ret['background-image'] += str_value[i][j] + ','
                    have['bg'] = True

                elif str_value[i][j] in repeat:
                    ret['background-repeat'] += str_value[i][j] + ','

                elif str_value[i][j] in attachment:
                    ret['background-attachment'] += str_value[i][j] + ','

                elif str_value[i][j] in clip and not have['clip']:
                    ret['background-clip'] += str_value[i][j] + ','
                    have['clip'] = True

                elif str_value[i][j] in origin:
                    ret['background-origin'] += str_value[i][j] + ','

                elif str_value[i][j][0] == '(':
                    ret['background-size'] += str_value[i][j][1:-1] + ','

                elif str_value[i][j] in pos or str_value[i][j][0].isnumeric() or str_value[i][j][0] is None:
                    ret['background-position'] += str_value[i][j]
                    if not have['pos']:
                        ret['background-position'] += ' '
                    else:
                        ret['background-position'] += ','

                    have['pos'] = True

                elif not have['color']:
                    ret['background-color'] += str_value[i][j] + ','
                    have['color'] = True

        for bg_prop, default_value in background_prop_default.iteritems():
            if ret[bg_prop] is not None:
                ret[bg_prop] = ret[bg_prop][:-1] + important

            else:
                ret[bg_prop] = default_value + important

        return ret

    # Merges all background properties
    # @param array $input_css
    # @return array
    # @version 1.0
    # @see dissolve_short_bg()
    # @todo full CSS 3 compliance
    def merge_bg(self, input_css):
        background_prop_default = GLOBALS['csstidy']['background_prop_default']

        #Max number of background images. CSS3 not yet fully implemented
        number_of_values = max(len(self.explode_ws(',', input_css['background-image'])), len(self.explode_ws(',', input_css['background-color'])), 1)

        #Array with background images to check if BG image exists
        bg_img_array = self.explode_ws(',', self.parser.gvw_important(input_css['background-image']))
        new_bg_value = ''
        important = ''

        for i in xrange(number_of_values):
            for bg_property, default_value in background_prop_default:
                #Skip if property does not exist
                if not input_css.has_key(bg_property):
                    continue

                cur_value = input_css[bg_property]

                #Skip some properties if there is no background image
                if len(bg_img_array) > i or bg_img_array[i] == 'none' and bg_property in frozenset(['background-size', 'background-position', 'background-attachment', 'background-repeat']):
                    continue

                #Remove !important
                if self.parser.is_important(cur_value):
                    important = ' !important'
                    cur_value = self.parser.gvw_important(cur_value)

                #Do not add default values
                if cur_value == default_value:
                    continue

                temp = self.explode_ws(',', cur_value)

                if len(temp) > i:
                    if bg_property == 'background-size':
                        new_bg_value += '(' + temp[i] + ') '

                    else:
                        new_bg_value += temp[i] + ' '

            new_bg_value = new_bg_value.strip()
            if i != (number_of_values-1):
                new_bg_value += ','

        #Delete all background-properties
        for bg_property, default_value in background_prop_default:
            del input_css[bg_property]

        #Add new background property
        if new_bg_value != '':
            input_css['background'] = new_bg_value + important

        return input_css