# CSSTidy - CSS Parser and Optimiser
#
# CSS Printing class
# This class prints CSS data generated by csstidy.
#
# This file is part of CSSTidy.
#
# CSSTidy is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# CSSTidy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CSSTidy; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# @license http://opensource.org/licenses/gpl-license.php GNU Public License
# @package csstidy
# @author Dj Gilcrease (digitalxero at gmail dot com) 2005-2006
# CSS Printing class
#
# This class prints CSS data generated by csstidy.
#
# @package csstidy
# @author Dj Gilcrease (digitalxero at gmail dot com) 2005-2006
# @version 1.0

import copy
from HTMLParser import HTMLParser
import datetime
from cgi import escape as htmlspecialchars

from tidydata import *

class CSSTidyPrint(object):
    # Saves the input CSS string
    # @var string
    # @access private
    _input_css = ''

    # Saves the formatted CSS string
    # @var string
    # @access public
    output_css = ''

    # Saves the formatted CSS string (plain text)
    # @var string
    # @access public
    output_css_plain = ''

    # Constructor
    # @param array $css contains the class csstidy
    # @access private
    # @version 1.0
    def __init__(self, css):
        self.parser    = css
        self.css       = css.css
        self.template  = css._template
        self.tokens    = css._tokens
        self.charset   = css._charset
        self._import    = css._import
        self.namespace = css._namespace

    # Resets output_css and output_css_plain (new css code)
    # @access private
    # @version 1.0
    def _reset(self):
        self.output_css = ''
        self.output_css_plain = ''

    # Returns the CSS code as plain text
    # @return string
    # @access public
    # @version 1.0
    def plain(self):
        self._print(True)
        return self.output_css_plain

    # Returns the formatted CSS code
    # @return string
    # @access public
    # @version 1.0
    def formatted(self):
        self._print(False)
        return self.output_css

    # Returns the formatted CSS Code and saves it into self.output_css and self.output_css_plain
    # @param bool $plain plain text or not
    # @access private
    # @version 2.0
    def _print(self, plain=False):
        if self.output_css and self.output_css_plain:
            return

        output = ''
        if not self.parser.get_cfg('preserve_css'):
            self._convert_raw_css()

        template = self.template[:]

        if plain:
            for item in xrange(len(template)):
                template[item] = strip_tags(template[item])

        if self.parser.get_cfg('timestamp'):
            self.tokens.insert(0, [COMMENT, ' CSSTidy ' + self.parser.version + ': ' + datetime.now().strftime("%a, %d %b %Y %H:%M:%S +0000") + ' '])

        if len(self.charset) != 0:
            output += template[0] + '@charset ' + template[5] + self.charset + template[6]

        if len(self._import) != 0:
            for i in xrange(len(self._import)):
                output += template[0] + '@import ' + template[5] + self._import[i] + template[6]

        if len(self.namespace) != 0:
            output += template[0] + '@namespace ' + template[5] + self.namespace + template[6]

        output += template[13]
        in_at_out = ''
        out = output

        #for key, token in self.tokens:
        for key in xrange(len(self.tokens)):
            token = self.tokens[key]
            if token[0] == AT_START:
                out += template[0] + self._htmlsp(token[1], plain) + template[1]
                out += in_at_out

            elif token[0] == SEL_START:
                if self.parser.get_cfg('lowercase_s'):
                    token[1] = token[1].lower()

                if len(token[1]) > 0 and token[1][0] != '@':
                    out += template[2] + self._htmlsp(token[1], plain)
                else:
                    out += template[0] + self._htmlsp(token[1], plain)

                out += template[3]

            elif token[0] == PROPERTY:
                if self.parser.get_cfg('case_properties') == 2:
                    token[1] = token[1].upper()

                if self.parser.get_cfg('case_properties') == 1:
                    token[1] = token[1].lower()

                out += template[4] + self._htmlsp(token[1], plain) + ':' + template[5]

            elif token[0] == VALUE:
                out += self._htmlsp(token[1], plain)

                if self._seeknocomment(key, 1) == SEL_END and self.parser.get_cfg('remove_last_;'):
                    out += template[6].replace(';', '')
                else:
                    out += template[6]

            elif token[0] == SEL_END:
                out += template[7]
                if self._seeknocomment(key, 1) != AT_END:
                    out += template[8]

            elif token[0] == AT_END:
                out = copy.copy(output)
                out += template[10] + in_at_out.replace("\n", "\n" + template[10])
                in_at_out = ''
                out += template[9]

            elif token[0] == COMMENT:
                out += template[11] + '/#' + self._htmlsp(token[1], plain) + '#/' + template[12]

        output = out.strip()

        if not plain:
            self.output_css = output
            self._print(True)
        else:
            self.output_css_plain = output

    # Gets the next token type which is $move away from $key, excluding comments
    # @param integer $key current position
    # @param integer $move move this far
    # @return mixed a token type
    # @access private
    # @version 1.0
    def _seeknocomment(self, key, move):
        go = -1
        if move > 0:
            go = 1

        i = key+1
        while abs(key-i)-1 < abs(move):
            if len(self.tokens) <= i:
                return

            if self.tokens[i][0] == COMMENT:
                move += 1
                i += go
                continue

            return self.tokens[i][0]

    # Converts self.css array to a raw array (self.tokens)
    # @access private
    # @version 1.0
    def _convert_raw_css(self):
        self.tokens = []

        for medium, val in self.parser.css.iteritems():
            if self.parser.get_cfg('sort_selectors'):
                keys = val.keys()
                keys.sort()
                val = map(val.get, keys)

            if (medium != DEFAULT_AT):
                self.parser._add_token(AT_START, medium, True)

            for selector, vali in val.iteritems():
                if self.parser.get_cfg('sort_properties'):
                    keys = vali.keys()
                    keys.sort()
                    vali = map(vali.get, keys)

                self.parser._add_token(SEL_START, selector, True)

                for prop, valj in vali.iteritems():
                    self.parser._add_token(PROPERTY, prop, True)
                    self.parser._add_token(VALUE, valj, True)

                self.parser._add_token(SEL_END, selector, True)

            if (medium != DEFAULT_AT):
                self.parser._add_token(AT_END, medium, True)

        self.tokens = self.parser._tokens

    # Same as htmlspecialchars, only that chars are not replaced if $plain !== true. This makes  print_code() cleaner.
    # @param string $string
    # @param bool $plain
    # @return string
    # @see csstidy_print::_print()
    # @access private
    # @version 1.0
    def _htmlsp(self, string, plain):
        if not plain:
            return htmlspecialchars(string).replace('"', '&quote;').replace("'", '&#039;')

        return string

    # Get compression ratio
    # @access public
    # @return float
    # @version 1.2
    def get_ratio(self):
        if not self.output_css_plain:
            self.formatted()

        return round((float(len(self.input_css)) - float(len(self.output_css_plain))) / float(len(self.input_css)), 3) * 100

    # Get difference between the old and new code in bytes and prints the code if necessary.
    # @access public
    # @return string
    # @version 1.1
    def get_diff(self):
        if not self.output_css_plain:
            self.formatted()

        diff = len(self.output_css_plain) - len(self.input_css)

        if diff > 0:
            return '+' + diff
        elif diff == 0:
            return '+-' + diff

        return diff

    # Get the size of either input or output CSS in KB
    # @param string $loc default is "output"
    # @access public
    # @return integer
    # @version 1.0
    def size(self, loc='output'):
        if loc == 'output' and  not self.output_css:
            self.formatted()

        if loc == 'input':
            return (len(self.input_css) / 1000)
        else:
            return (len(self.output_css_plain) / 1000)


class HTMLStripper(HTMLParser):
    def __init__(self):
        self.accum = ""

    def handle_data(self, data):  # quote cdata literally
        self.accum += data

    def handle_entityref(self, name): # entities must be preserved exactly
        self.accum += ""

    def handle_starttag(self, tag, attrs):
        self.accum += ""

    def handle_startendtag(self, tag, attrs):
        self.accum += ""

    def handle_endtag(self, tag):
        self.accum += ""

    def handle_charref(self, name):  # charrefs too
        self.accum += ""

def strip_tags(string, **kwargs):
    """
        Return string tripped of html tags.
    """
    htmlstripper = HTMLStripper()
    htmlstripper.reset()
    htmlstripper.accum = ""
    htmlstripper.feed(string)
    htmlstripper.close()
    return htmlstripper.accum